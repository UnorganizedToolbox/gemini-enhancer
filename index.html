<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4451508889015447" crossorigin="anonymous"></script>
    <script src="https://cdn.auth0.com/js/auth0-spa-js/2.1/auth0-spa-js.production.js"></script>
    <title>図付きAI</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" xintegrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" xintegrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" xintegrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js" xintegrity="sha512-BNaRQnYJYiPSqHHDb58B0yaPfCu+Wgds8Gp/gU33kqBtgNS4tSPHuGibyoVBL5gI9kLmbG4dGdGmkSFoPAccJg==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js" xintegrity="sha512-qZvrmS2ekKPF2mSznTQsxqPgnpkI4DNTlrdUmTzrDgektczlKNRRhy5X5AAOnx5S09ydFYWWNSfcEqDTTHgtNA==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', 'Noto Sans JP', sans-serif;
        }
        .loader {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #3498db;
            border-radius: 50%;
            width: 24px;
            height: 24px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .prose h1 { font-size: 1.875rem; }
        .prose h2 { font-size: 1.5rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.5rem; margin-top: 1.5rem;}
        .prose h3 { font-size: 1.25rem; }
        .prose p, .prose ul, .prose ol { line-height: 1.75; }
        .prose pre { background-color: #f3f4f6; padding: 1rem; border-radius: 0.5rem; }
        #chat-history { scroll-behavior: smooth; }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col">

    <header class="bg-white shadow-sm w-full">
        <div class="container mx-auto p-4 max-w-5xl text-center">
             <h1 class="text-2xl md:text-3xl font-bold text-gray-900">図付きAI</h1>
             <p class="text-gray-500 text-sm mt-1">AIとの対話で、Markdown・図(Mermaid)・数式(LaTeX)を含む解説記事を生成</p>
        </div>
        <div id="auth-area">
            <button id="btn-login" class="bg-blue-600 text-white font-bold py-2 px-4 rounded">ログイン</button>
            <button id="btn-logout" class="hidden bg-gray-500 text-white font-bold py-2 px-4 rounded">ログアウト</button>
        </div>
    </header>

    <main class="flex-1 container mx-auto p-4 max-w-5xl flex flex-col overflow-hidden">
        <div id="chat-history" class="flex-1 space-y-4 overflow-y-auto p-4 bg-white rounded-t-lg shadow-inner">
            <!-- Chat messages will be appended here -->
             <div class="p-4 bg-blue-50 rounded-lg text-gray-700">
                <p class="font-semibold">アシスタント</p>
                <p>こんにちは！どのような解説記事を作成しますか？</p>
            </div>
        </div>
        
        <div id="chat-input-area" class="p-4 bg-white border-t border-gray-200 rounded-b-lg">
             <div id="error-box" class="mb-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative hidden" role="alert">
                <strong class="font-bold">エラー:</strong>
                <span class="block sm:inline" id="error-message"></span>
            </div>
            <div class="flex items-center space-x-3">
                <textarea id="prompt" rows="1" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition resize-none" placeholder="メッセージを入力..."></textarea>
                <button id="generate-btn" class="bg-blue-600 text-white font-bold py-3 px-5 rounded-lg hover:bg-blue-700 transition-all duration-300 ease-in-out flex items-center justify-center disabled:bg-gray-400">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" /></svg>
                </button>
            </div>
        </div>
    </main>

    <script>
    // --- 1. 要素の取得 ---
    const loginBtn = document.getElementById('btn-login');
    const logoutBtn = document.getElementById('btn-logout');
    const generateBtn = document.getElementById('generate-btn');
    const promptTextarea = document.getElementById('prompt');
    const chatHistoryDiv = document.getElementById('chat-history');
    const errorBox = document.getElementById('error-box');
    const errorMessage = document.getElementById('error-message');
    
    // --- 2. 変数の初期化 ---
    let auth0Client = null;
    let chatHistory = [];

    // --- 3. Auth0 クライアントの設定と初期化 ---
    const auth0Config = {
      domain: "dev-x55cpyrdwlq2c0p2.us.auth0.com",      // ★★★ ここをあなたの情報に書き換える ★★★
      clientId: "gNGTdI71kRMz2xAzG0gGgTzbGZJKzqD8", // ★★★ ここをあなたの情報に書き換える ★★★
      authorizationParams: {
        redirect_uri: window.location.origin,
        // audience: "あなたのAPIのAudience" // API設定をしている場合はこれも必要
        audience: "https://gemini-enhancer.vercel.app/api"
      }
    };

    window.addEventListener('load', async () => {
      try {
        auth0Client = await auth0.createAuth0Client(auth0Config);
        const query = window.location.search;
        if (query.includes("code=") && query.includes("state=")) {
          await auth0Client.handleRedirectCallback();
          window.history.replaceState({}, document.title, "/");
        }
      } catch(e) {
        console.error("Auth0の初期化に失敗しました:", e);
        showError("認証サービスの初期化に失敗しました。キーが正しいか確認してください。");
      } finally {
        updateUI();
      }
    });

    // --- 4. UI更新と認証イベントの処理 ---
    const updateUI = async () => {
      if (!auth0Client) return;
      try {
        const isAuthenticated = await auth0Client.isAuthenticated();
        loginBtn.classList.toggle('hidden', isAuthenticated);
        logoutBtn.classList.toggle('hidden', !isAuthenticated);
        promptTextarea.disabled = !isAuthenticated;
        generateBtn.disabled = !isAuthenticated;
        if(!isAuthenticated) {
          promptTextarea.placeholder = "利用するにはログインしてください";
        } else {
          promptTextarea.placeholder = "メッセージを入力...";
        }
      } catch(e) {
        console.error("UI update failed:", e);
      }
    };

    loginBtn.addEventListener('click', () => auth0Client.loginWithRedirect());
    logoutBtn.addEventListener('click', () => auth0Client.logout({ logoutParams: { returnTo: window.location.origin } }));

    // --- 5. チャット機能のコアロジック ---
    mermaid.initialize({ startOnLoad: false, theme: 'default' });

    promptTextarea.addEventListener('input', () => {
        promptTextarea.style.height = 'auto';
        promptTextarea.style.height = (promptTextarea.scrollHeight) + 'px';
    });
    promptTextarea.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            generateContent();
        }
    });
    generateBtn.addEventListener('click', generateContent);

    async function generateContent() {
        const userPrompt = promptTextarea.value;
        if (!userPrompt.trim()) return;
        addMessageToHistory('user', userPrompt);
        promptTextarea.value = '';
        promptTextarea.style.height = 'auto';
        generateBtn.disabled = true;
        addTypingIndicator();
        try {
            const markdownText = await generateTextFromApi();
            removeTypingIndicator();
            addMessageToHistory('model', markdownText);
        } catch (error) {
            console.error('Error:', error);
            showError(error.message || '不明なエラーが発生しました。');
            removeTypingIndicator();
        } finally {
            const isAuthenticated = await auth0Client.isAuthenticated();
            generateBtn.disabled = !isAuthenticated;
        }
    }

    async function generateTextFromApi() {
        if (!auth0Client) throw new Error("認証クライアントが初期化されていません。");
        
        const isAuthenticated = await auth0Client.isAuthenticated();
        if (!isAuthenticated) {
            throw new Error("ログインが必要です。");
        }
        
        const accessToken = await auth0Client.getTokenSilently();

        const systemPrompt = `あなたは優秀なテクニカルライターで、ユーザーと対話しながら解説記事を作成します。

# 利用可能なツール
1.  **Markdown**: 構造化された文章を作成します。
2.  **Mermaid**: \`\`\`mermaid コードブロックで図を作成します。フローチャート、シーケンス図などが利用可能です。
3.  **LaTeX**: \`$...\` や \`$$...\` で数式を表現します。

# 指示
- ユーザーの要求に応じて、これらのツールを適切に組み合わせ、プロフェッショナルな解説を生成してください。
- 特に、ハーバー・ボッシュ法のような化学プロセスや、システムのワークフローを説明する場合は、Mermaidを積極的に使い、フローチャートとして視覚的に表現してください。
- **Mermaidの注意点**: ノードのテキストに括弧 \`()\` やコロン \`:\` などの特殊文字が含まれる場合は、必ずテキスト全体をダブルクォーテーション \`""\` で囲んでください。例: \`A["天然ガス (CH4)"] --> B["N2: 精製"]\`
- 以前の会話内容を記憶し、文脈に沿った応答をしてください。
- **参考文献**: 解説の最後には必ず「## 参考文献」というセクションを設け、参考にした情報源をリストアップしてください。本文中では、関連する記述の直後に \`[1]\`, \`[2]\` のように引用番号を付与してください。仮に参考文献が存在しない場合、その旨を記載するか、単に『なし』と記載してください
- **参考になるもの**: 必要であれば、「## 参考文献」セクションの直後に参考となるウェブサイト・書籍等をリスト形式で提示してください。
    - ウェブサイトの場合：著者名（任意）「記事タイトル」サイト名. <URL>. (閲覧日: YYYY-MM-DD)
    - 書籍の場合：著者名『書籍名』出版社, 出版年
    - 直接参照した情報源がない場合:参考文献セクションには「なし」とだけ記載してください
    - 読者のさらなる学習のために推奨できる資料がある場合は、「## 参考資料」というセクションを参考文献の後に設け、リスト形式で提示してください。`; // ★★★ ここにプロンプトを貼り付け ★★★

        const response = await fetch('/api/generate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`
            },
            body: JSON.stringify({ 
                chatHistory: chatHistory,
                systemPrompt: systemPrompt
            }),
        });

        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `サーバーエラー (${response.status})`);
        }
        const data = await response.json();
        return data.text;
    }

    // --- 6. チャットUIのヘルパー関数群 ---
    function addMessageToHistory(role, content) {
        const messageWrapper = document.createElement('div');
        if (role === 'user') {
            messageWrapper.className = "p-4 bg-gray-100 rounded-lg ml-auto max-w-4/5";
            messageWrapper.innerHTML = `<p class="font-semibold text-right">あなた</p><p class="whitespace-pre-wrap">${content.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</p>`;
            chatHistory.push({ role: "user", parts: [{ text: content }] });
        } else {
            const responseId = `model-response-${chatHistory.length}`;
            messageWrapper.id = responseId;
            messageWrapper.className = "p-4 bg-blue-50 rounded-lg text-gray-700";
            const exportButtons = `
                <div class="export-buttons flex items-center gap-2 mt-3 border-t pt-2">
                    <button onclick="copyToClipboard('${responseId}')" class="text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 px-2 py-1 rounded">Markdownコピー</button>
                    <button onclick="exportPdf('${responseId}')" class="text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 px-2 py-1 rounded">PDFエクスポート</button>
                </div>`;
            messageWrapper.innerHTML = `<p class="font-semibold">アシスタント</p><div class="prose max-w-none model-content">${content}</div>${exportButtons}`;
            chatHistory.push({ role: "model", parts: [{ text: content }] });
            renderContent(messageWrapper.querySelector('.model-content'));
        }
        chatHistoryDiv.appendChild(messageWrapper);
        chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
    }

    function addTypingIndicator() {
        const typingIndicator = document.createElement('div');
        typingIndicator.id = "typing-indicator";
        typingIndicator.className = "p-4 bg-blue-50 rounded-lg text-gray-700 flex items-center space-x-2";
        typingIndicator.innerHTML = `<p class="font-semibold">アシスタント</p><div class="loader"></div>`;
        chatHistoryDiv.appendChild(typingIndicator);
        chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
    }

    function removeTypingIndicator() {
        const indicator = document.getElementById('typing-indicator');
        if (indicator) indicator.remove();
    }

    function replaceCitationsWithLinks(element, refCount) {
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
        let node;
        const nodesToModify = [];
        while (node = walker.nextNode()) {
            if (node.parentElement.closest('pre, code')) continue;
            if (/\[\d+\]/.test(node.nodeValue)) {
                nodesToModify.push(node);
            }
        }
        nodesToModify.forEach(node => {
            const fragment = document.createDocumentFragment();
            const parts = node.nodeValue.split(/(\[\d+\])/g);
            parts.forEach(part => {
                const match = part.match(/^\[(\d+)\]$/);
                if (match) {
                    const num = parseInt(match[1], 10);
                    if (num > 0 && num <= refCount) {
                        const sup = document.createElement('sup');
                        sup.className = "font-bold text-blue-600";
                        const link = document.createElement('a');
                        link.href = `#ref-${num}`;
                        link.textContent = part;
                        sup.appendChild(link);
                        fragment.appendChild(sup);
                    } else {
                        fragment.appendChild(document.createTextNode(part));
                    }
                } else {
                    fragment.appendChild(document.createTextNode(part));
                }
            });
            node.parentNode.replaceChild(fragment, node);
        });
    }

    async function renderContent(targetElement) {
        let markdown = targetElement.innerHTML;
        const mermaidBlocks = [];
        markdown = markdown.replace(/```mermaid\n([\s\S]*?)\n```/g, (match, code) => {
            const placeholderId = `mermaid-placeholder-${mermaidBlocks.length}`;
            mermaidBlocks.push(code);
            return `<div id="${placeholderId}"></div>`;
        });
        targetElement.innerHTML = marked.parse(markdown);
        
        const refHeader = Array.from(targetElement.querySelectorAll('h1, h2')).find(h => h.textContent.trim() === '参考文献');
        let refCount = 0;
        if (refHeader) {
            let refList = refHeader.nextElementSibling;
            while (refList && !['OL', 'UL'].includes(refList.tagName)) {
                refList = refList.nextElementSibling;
            }
            if (refList) {
                const listItems = refList.querySelectorAll('li');
                refCount = listItems.length;
                listItems.forEach((li, index) => {
                    li.id = `ref-${index + 1}`;
                });
            }
        }
        if (refCount > 0) {
            replaceCitationsWithLinks(targetElement, refCount);
        }

        mermaidBlocks.forEach((code, index) => {
            const placeholder = targetElement.querySelector(`#mermaid-placeholder-${index}`);
            if (placeholder) {
                const container = document.createElement('div');
                container.className = 'mermaid';
                const decoder = document.createElement('textarea');
                decoder.innerHTML = code;
                container.textContent = decoder.value;
                placeholder.replaceWith(container);
            }
        });

        if (targetElement.querySelectorAll('.mermaid').length > 0) {
            try {
                await mermaid.run({ nodes: targetElement.querySelectorAll('.mermaid') });
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                targetElement.querySelectorAll('.mermaid').forEach(el => {
                    if (el.innerHTML.trim() === '') {
                         el.innerHTML = `<div class="p-2 border border-red-400 bg-red-100 text-red-700 rounded">Mermaid図の描画に失敗しました。<br><pre>${el.textContent}</pre></div>`;
                    }
                });
            }
        }
        
        if (window.renderMathInElement) {
            renderMathInElement(targetElement, {
                delimiters: [ {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false} ],
                throwOnError: false
            });
        }
    }
    
    async function copyToClipboard(elementId) {
        const index = parseInt(elementId.replace('model-response-', ''));
        const originalMarkdown = chatHistory[index].parts[0].text;
        try {
            await navigator.clipboard.writeText(originalMarkdown);
            const button = document.querySelector(`#${elementId} button:first-child`);
            const originalText = button.textContent;
            button.textContent = 'コピーしました！';
            setTimeout(() => { button.textContent = originalText; }, 2000);
        } catch (err) {
            console.error('Failed to copy: ', err);
        }
    }

    async function exportPdf(elementId) {
        const { jsPDF } = window.jspdf;
        const originalContent = document.querySelector(`#${elementId} .model-content`);
        const printableArea = document.createElement('div');
        printableArea.style.cssText = 'position:absolute; left:-9999px; width:1024px; padding:50px; background:#fff;';
        printableArea.className = 'prose max-w-none';
        const headerHtml = `<div style="margin-bottom: 40px; border-bottom: 1px solid #ddd; padding-bottom: 20px;"><h1 style="font-size: 24px; margin: 0;">生成された解説記事</h1><p style="text-align: right; margin: 0; color: #555;">${new Date().toLocaleString('ja-JP')}</p></div>`;
        const contentClone = originalContent.cloneNode(true);
        printableArea.innerHTML = headerHtml;
        printableArea.appendChild(contentClone);
        document.body.appendChild(printableArea);
        const canvas = await html2canvas(printableArea, { scale: 2 });
        document.body.removeChild(printableArea);
        const imgData = canvas.toDataURL('image/png');
        const pdf = new jsPDF({ orientation: 'portrait', unit: 'px', format: [canvas.width, canvas.height] });
        pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);
        pdf.save('gemini-export.pdf');
    }

    function showError(message) {
        errorMessage.textContent = message;
        errorBox.classList.remove('hidden');
    }
</script>
</body>
</html>













