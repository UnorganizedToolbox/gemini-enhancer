<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>図付きAIジェネレーター</title>
    <!--<script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-4451508889015447" crossorigin="anonymous"></script>-->
    <script src="https://cdn.auth0.com/js/auth0-spa-js/2.1/auth0-spa-js.production.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .prose h1 { font-size: 1.875rem; } .prose h2 { font-size: 1.5rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.5rem; margin-top: 1.5rem;}
        .prose h3 { font-size: 1.25rem; } .prose p, .prose ul, .prose ol { line-height: 1.75; }
        .prose pre { background-color: #f3f4f6; padding: 1rem; border-radius: 0.5rem; }
        #chat-history { scroll-behavior: smooth; }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col">

    <header class="bg-white shadow-sm w-full">
        <div class="container mx-auto p-4 max-w-5xl flex justify-between items-center">
            <div class="text-left">
                <h1 class="text-2xl md:text-3xl font-bold text-gray-900">図付きAIジェネレーター</h1>
                <p class="text-gray-500 text-sm mt-1">AIとの対話で、Markdown・図・数式を含む解説記事を生成</p>
            </div>
            <div id="auth-area" class="flex items-center space-x-4">
                <button id="btn-logout" class="hidden bg-gray-500 text-white font-bold py-2 px-4 rounded">ログアウト</button>
            </div>
        </div>
    </header>

    <main class="flex-1 container mx-auto p-4 max-w-5xl flex flex-col overflow-hidden">
        <div id="mode-selection-area" class="p-4 bg-white rounded-lg shadow-md mb-4">
            <h3 class="font-semibold text-lg text-center mb-4">ご利用方法を選択してください</h3>
            <div class="flex justify-center space-x-8">
                <div><input type="radio" id="mode-login" name="usage-mode" value="login" class="mr-2"><label for="mode-login">ログインして利用 (5回/日)</label></div>
                <div><input type="radio" id="mode-byok" name="usage-mode" value="byok" class="mr-2"><label for="mode-byok">APIキーを入力して利用 (無制限)</label></div>
            </div>
            <div id="login-action-area" class="hidden text-center mt-4">
                <button id="btn-login" class="bg-blue-600 text-white font-bold py-2 px-4 rounded hover:bg-blue-700">Googleアカウントでログイン</button>
            </div>
            <div id="byok-action-area" class="hidden mt-4 p-4 border-t">
                <div>
                    <label for="api-key-input" class="block text-sm font-medium text-gray-700">ご自身のGemini APIキーを入力してください。</label>
                    <div class="flex items-center gap-2">
                        <input type="password" id="api-key-input" class="w-full px-3 py-2 text-gray-700 border rounded-lg focus:outline-none" placeholder="g.co/ai/idx... から取得したキー">
                        <button id="save-api-key-btn" class="px-4 py-2 bg-blue-600 text-white font-medium rounded-md hover:bg-blue-700">保存</button>
                    </div>
                    <p class="mt-2 text-xs text-red-500">注意：APIキーはブラウザ内に保存されます。公共のPCなどでは設定しないでください。</p>
                </div>
                <div>
                    <label for="model-select" class="block text-sm font-medium text-gray-700">使用するモデル:</label>
                    <select id="model-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                        <option value="gemini-2.5-pro">2.5 Pro（最高品質・最高値）
                        <option value="gemini-1.5-pro-latest">1.5 Pro (標準・高品質)</option>
                        <option value="gemini-1.5-flash-latest">1.5 Flash (最速・最安値)</option>
                    </select>
                </div>
            </div>
        </div>

        <div id="chat-container" class="hidden flex-1 flex flex-col overflow-hidden">
            <div id="chat-history" class="flex-1 space-y-4 overflow-y-auto p-4 bg-white rounded-t-lg shadow-inner">
                <div class="p-4 bg-blue-50 rounded-lg text-gray-700">
                    <p class="font-semibold">アシスタント</p><p>こんにちは！どのような解説記事を作成しますか？</p>
                </div>
            </div>
            <div id="chat-input-area" class="p-4 bg-white border-t border-gray-200 rounded-b-lg">
                <div id="error-box" class="mb-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative hidden" role="alert">
                    <strong class="font-bold">エラー:</strong><span class="block sm:inline" id="error-message"></span>
                </div>
                <div class="flex items-center space-x-3">
                    <textarea id="prompt" rows="1" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition resize-none" placeholder="メッセージを入力..."></textarea>
                    <button id="generate-btn" class="bg-blue-600 text-white font-bold py-3 px-5 rounded-lg hover:bg-blue-700 flex items-center justify-center disabled:bg-gray-400">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" /></svg>
                    </button>
                </div>
            </div>
        </div>
    </main>

    <script>
        // --- 1. 要素の取得 ---
        const loginBtn = document.getElementById('btn-login');
        const logoutBtn = document.getElementById('btn-logout');
        const generateBtn = document.getElementById('generate-btn');
        const promptTextarea = document.getElementById('prompt');
        const chatHistoryDiv = document.getElementById('chat-history');
        const errorBox = document.getElementById('error-box');
        const errorMessage = document.getElementById('error-message');
        const modeSelectionArea = document.getElementById('mode-selection-area');
        const chatContainer = document.getElementById('chat-container');
        const radioLogin = document.getElementById('mode-login');
        const radioByok = document.getElementById('mode-byok');
        const loginActionArea = document.getElementById('login-action-area');
        const byokActionArea = document.getElementById('byok-action-area');
        const apiKeyInput = document.getElementById('api-key-input');
        const saveApiKeyBtn = document.getElementById('save-api-key-btn');
        
        // --- 2. 変数の初期化 ---
        let auth0Client = null;
        let chatHistory = [{ role: "model", parts: [{ text: "こんにちは！どのような解説記事を作成しますか？" }] }];

        // --- 3. Auth0 クライアントの設定と初期化 ---
        const auth0Config = {
            domain: "dev-x55cpyrdwlq2c0p2.us.auth0.com",
            clientId: "gNGTdI71kRMz2xAzG0gGgTzbGZJKzqD8",
            authorizationParams: {
                redirect_uri: window.location.origin,
                audience: "https://gemini-enhancer.vercel.app/api"
            }
        };

        window.addEventListener('load', async () => {
            try {
                auth0Client = await auth0.createAuth0Client(auth0Config);
                const query = window.location.search;
                if (query.includes("code=") && query.includes("state=")) {
                    await auth0Client.handleRedirectCallback();
                    window.history.replaceState({}, document.title, "/");
                }
            } catch(e) {
                console.error("Auth0の初期化に失敗:", e);
                showError("認証サービスの初期化に失敗。");
            } finally {
                updateUI();
            }
        });

        // --- 4. UI更新とイベント処理 ---
        const updateUI = async () => {
            if (!auth0Client) return;
            const isAuthenticated = await auth0Client.isAuthenticated();
            const userApiKey = localStorage.getItem('user_gemini_api_key');
            const isLoggedInOrHasKey = isAuthenticated || userApiKey;

            modeSelectionArea.classList.toggle('hidden', isLoggedInOrHasKey);
            chatContainer.classList.toggle('hidden', !isLoggedInOrHasKey);
            logoutBtn.classList.toggle('hidden', !isAuthenticated && !userApiKey);
        };

        loginBtn.addEventListener('click', () => auth0Client.loginWithRedirect());
        logoutBtn.addEventListener('click', () => {
            localStorage.removeItem('user_gemini_api_key');
            auth0Client.logout({ logoutParams: { returnTo: window.location.origin } });
        });
        
        radioLogin.addEventListener('change', () => {
            loginActionArea.classList.remove('hidden');
            byokActionArea.classList.add('hidden');
        });
        radioByok.addEventListener('change', () => {
            loginActionArea.classList.add('hidden');
            byokActionArea.classList.remove('hidden');
        });
        
        saveApiKeyBtn.addEventListener('click', () => {
            const userApiKey = apiKeyInput.value.trim();
            if (userApiKey) {
                localStorage.setItem('user_gemini_api_key', userApiKey);
                alert('APIキーを保存しました。');
                updateUI();
            } else {
                alert('APIキーが入力されていません。');
            }
        });
    // --- 5. チャット機能のコアロジック ---
    mermaid.initialize({ startOnLoad: false, theme: 'default' });

    promptTextarea.addEventListener('input', () => {
        promptTextarea.style.height = 'auto';
        promptTextarea.style.height = (promptTextarea.scrollHeight) + 'px';
    });
    promptTextarea.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            generateContent();
        }
    });
    generateBtn.addEventListener('click', generateContent);

    async function generateContent() {
        const userApiKey = localStorage.getItem('user_gemini_api_key')
        const userPrompt = promptTextarea.value;
        if (!userPrompt.trim()) return;
        addMessageToHistory('user', userPrompt);
        promptTextarea.value = '';
        promptTextarea.style.height = 'auto';
        generateBtn.disabled = true;
        addTypingIndicator();
        try {
            const markdownText = await generateTextFromApi();
            removeTypingIndicator();
            addMessageToHistory('model', markdownText);
        } catch (error) {
            console.error('Error:', error);
            showError(error.message || '不明なエラーが発生しました。');
            removeTypingIndicator();
        } finally {
            const isAuthenticated = await auth0Client.isAuthenticated();
            generateBtn.disabled = !isAuthenticated;
        }
    }

    // index.htmlの<script>タグ内

async function generateTextFromApi() {
    const userApiKey = localStorage.getItem('user_gemini_api_key');
    const systemPrompt = `## あなたの役割と行動原則
あなたは、ユーザーの指示に応答する、自律的なテクニカルライターです。対話型のアシスタントではありません。
ユーザーからの最初のプロンプトを、記事作成のための唯一かつ完全な指示として解釈してください。
不明な点があっても、確認のための質問を返してはいけません。与えられた情報と、利用可能なツールを最大限活用し、必ず一度の応答で記事全体を完成させてください。

## 思考プロセス
1.  まず、ユーザーの要求を分析し、自身の知識が古い、あるいは不足している可能性があるかを判断します。
2.  もし情報が古い、あるいは不足していると判断した場合、必ず\`Google Search\`ツールを実行して、信頼できる最新の情報源を複数見つけ出します。
3.  収集した情報と、以下のツールや指示に基づいて、一つの完成された解説記事を生成します。
## 利用可能なツール
- **google_search**: 最新の情報をWebから検索します。検索クエリを引数として渡します。
Markdown: 構造化された文章を作成します。
Mermaid: フローチャートや図を作成します。
Mermaidの成功例...以下は完全なMermaidの例です。これを参考に、常に正確なコードを生成してください。
\`\`\`Mermaid
graph TD
    A[処理開始] --> B["データ入力 (ID: 123)"];
    B --> C{検証};
    C -- OK --> D[正常処理];
    C -- NG --> E[エラー処理];
    subgraph "詳細プロセス"
        D --> F[プロセスA];
        F --> G((完了));
    end
    E --> G;
    style G fill:#dff,stroke:#333,stroke-width:2px;
\`\`\`
LaTeX: 数式を表現します。
## 出力に関する指示
Mermaid: フローチャートを作成する際は、原則として**上から下へ（TDまたはTB）**のレイアウトを使用してください。ノードのテキストに特殊文字 () : を含む場合は、テキスト全体を "" で囲んでください。
参考文献と資料:
実際に参照したWebページや書籍のみを、解説の最後に「## 参考文献」セクションを設け、以下の記法に従ってリストアップしてください。リストアップする際、その資料ごとに改行してください。本文中の関連箇所には [1], [2] のように引用番号を付与してください。
ウェブサイト: 著者名（任意）「記事タイトル」サイト名. <URL>. (閲覧日: {{YYYY-MM-DD}})
書籍: 著者名『書籍名』出版社, 出版年.
閲覧日が不明な場合は（閲覧日: 不明）のように記載してください。直接参照した情報源がない場合、参考文献セクションには「なし」とだけ記載してください。
読者のさらなる学習のために推奨できる資料がある場合は、「## 参考資料」というセクションを参考文献の後に設け、リスト形式で提示してください。`;

    if (!userApiKey) {
        // --- 無料ユーザー（あなたのサーバー経由）の処理 ---
        console.log("サーバー経由で実行します（回数制限・認証あり）");

        if (!auth0Client) throw new Error("認証クライアントが初期化されていません。");
        const isAuthenticated = await auth0Client.isAuthenticated();
        if (!isAuthenticated) throw new Error("ログインが必要です。");
        
        const accessToken = await auth0Client.getTokenSilently();

        const response = await fetch('/api/generate', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${accessToken}`
            },
            bobody: JSON.stringify({ 
                chatHistory: chatHistory.slice(0, -1), // 最後（ユーザーの入力）を除いた会話履歴
                userPrompt: chatHistory[chatHistory.length - 1].parts[0].text, // ユーザーが最後に入力した内容
                systemPrompt: systemPrompt
            }),
        });
        if (!response.ok) {
            const errorData = await response.json();
            throw new Error(errorData.error || `サーバーエラー (${response.status})`);
        }
        const data = await response.json();
        return data.text;

    } else {
        // --- BYOKユーザー（Google APIへ直接）の処理 ---
        console.log("ユーザー提供のAPIキーを使用して直接実行します。");

        const selectedModel = document.getElementById('model-select').value;
        const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${selectedModel}:generateContent?key=${userApiKey}`;
        
        const payload = {
            contents: chatHistory,
            systemInstruction: {
                parts: [{ text: systemPrompt }],
            },
        };

        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify(payload),
            });

            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(`Google API エラー (${response.status}): ${errorData.error?.message || '不明なエラー'}`);
            }

            const result = await response.json();
            const modelResponseText = result.candidates?.[0]?.content?.parts?.[0]?.text;

            if (!modelResponseText) {
                throw new Error("APIからの応答が予期した形式ではありません。");
            }
            return modelResponseText;

        } catch (error) {
            console.error("Google API direct call error:", error);
            // エラーメッセージにAPIキーが含まれないように配慮
            if (error.message.includes(userApiKey)) {
                throw new Error("Google APIへの接続中にエラーが発生しました。APIキーが正しいか確認してください。");
            }
            throw error;
        }
    }
}

    // --- 6. チャットUIのヘルパー関数群 ---
    function addMessageToHistory(role, content) {
        const messageWrapper = document.createElement('div');
        if (role === 'user') {
            messageWrapper.className = "p-4 bg-gray-100 rounded-lg ml-auto max-w-4/5";
            messageWrapper.innerHTML = `<p class="font-semibold text-right">あなた</p><p class="whitespace-pre-wrap">${content.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</p>`;
            chatHistory.push({ role: "user", parts: [{ text: content }] });
        } else {
            const responseId = `model-response-${chatHistory.length}`;
            messageWrapper.id = responseId;
            messageWrapper.className = "p-4 bg-blue-50 rounded-lg text-gray-700";
            const exportButtons = `
                <div class="export-buttons flex items-center gap-2 mt-3 border-t pt-2">
                    <button onclick="copyToClipboard('${responseId}')" class="text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 px-2 py-1 rounded">Markdownコピー</button>
                    <button onclick="exportPdf('${responseId}')" class="text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 px-2 py-1 rounded">PDFエクスポート</button>
                </div>`;
            messageWrapper.innerHTML = `<p class="font-semibold">アシスタント</p><div class="prose max-w-none model-content">${content}</div>${exportButtons}`;
            chatHistory.push({ role: "model", parts: [{ text: content }] });
            renderContent(messageWrapper.querySelector('.model-content'));
        }
        chatHistoryDiv.appendChild(messageWrapper);
        chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
    }

    function addTypingIndicator() {
        const typingIndicator = document.createElement('div');
        typingIndicator.id = "typing-indicator";
        typingIndicator.className = "p-4 bg-blue-50 rounded-lg text-gray-700 flex items-center space-x-2";
        typingIndicator.innerHTML = `<p class="font-semibold">アシスタント</p><div class="loader"></div>`;
        chatHistoryDiv.appendChild(typingIndicator);
        chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
    }

    function removeTypingIndicator() {
        const indicator = document.getElementById('typing-indicator');
        if (indicator) indicator.remove();
    }

    function replaceCitationsWithLinks(element, refCount) {
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
        let node;
        const nodesToModify = [];
        while (node = walker.nextNode()) {
            if (node.parentElement.closest('pre, code')) continue;
            if (/\[\d+\]/.test(node.nodeValue)) {
                nodesToModify.push(node);
            }
        }
        nodesToModify.forEach(node => {
            const fragment = document.createDocumentFragment();
            const parts = node.nodeValue.split(/(\[\d+\])/g);
            parts.forEach(part => {
                const match = part.match(/^\[(\d+)\]$/);
                if (match) {
                    const num = parseInt(match[1], 10);
                    if (num > 0 && num <= refCount) {
                        const sup = document.createElement('sup');
                        sup.className = "font-bold text-blue-600";
                        const link = document.createElement('a');
                        link.href = `#ref-${num}`;
                        link.textContent = part;
                        sup.appendChild(link);
                        fragment.appendChild(sup);
                    } else {
                        fragment.appendChild(document.createTextNode(part));
                    }
                } else {
                    fragment.appendChild(document.createTextNode(part));
                }
            });
            node.parentNode.replaceChild(fragment, node);
        });
    }

    async function renderContent(targetElement) {
        let markdown = targetElement.innerHTML;
        const mermaidBlocks = [];
        markdown = markdown.replace(/```mermaid\n([\s\S]*?)\n```/g, (match, code) => {
            const placeholderId = `mermaid-placeholder-${mermaidBlocks.length}`;
            mermaidBlocks.push(code);
            return `<div id="${placeholderId}"></div>`;
        });
        targetElement.innerHTML = marked.parse(markdown);
        
        const refHeader = Array.from(targetElement.querySelectorAll('h1, h2')).find(h => h.textContent.trim() === '参考文献');
        let refCount = 0;
        if (refHeader) {
            let refList = refHeader.nextElementSibling;
            while (refList && !['OL', 'UL'].includes(refList.tagName)) {
                refList = refList.nextElementSibling;
            }
            if (refList) {
                const listItems = refList.querySelectorAll('li');
                refCount = listItems.length;
                listItems.forEach((li, index) => {
                    li.id = `ref-${index + 1}`;
                });
            }
        }
        if (refCount > 0) {
            replaceCitationsWithLinks(targetElement, refCount);
        }

        mermaidBlocks.forEach((code, index) => {
            const placeholder = targetElement.querySelector(`#mermaid-placeholder-${index}`);
            if (placeholder) {
                const container = document.createElement('div');
                container.className = 'mermaid';
                const decoder = document.createElement('textarea');
                decoder.innerHTML = code;
                container.textContent = decoder.value;
                placeholder.replaceWith(container);
            }
        });

        if (targetElement.querySelectorAll('.mermaid').length > 0) {
            try {
                await mermaid.run({ nodes: targetElement.querySelectorAll('.mermaid') });
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                targetElement.querySelectorAll('.mermaid').forEach(el => {
                    if (el.innerHTML.trim() === '') {
                         el.innerHTML = `<div class="p-2 border border-red-400 bg-red-100 text-red-700 rounded">Mermaid図の描画に失敗しました。<br><pre>${el.textContent}</pre></div>`;
                    }
                });
            }
        }
        
        if (window.renderMathInElement) {
            renderMathInElement(targetElement, {
                delimiters: [ {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false} ],
                throwOnError: false
            });
        }
    }
    
    async function copyToClipboard(elementId) {
        const index = parseInt(elementId.replace('model-response-', ''));
        const originalMarkdown = chatHistory[index].parts[0].text;
        try {
            await navigator.clipboard.writeText(originalMarkdown);
            const button = document.querySelector(`#${elementId} button:first-child`);
            const originalText = button.textContent;
            button.textContent = 'コピーしました！';
            setTimeout(() => { button.textContent = originalText; }, 2000);
        } catch (err) {
            console.error('Failed to copy: ', err);
        }
    }

    async function exportPdf(elementId) {
    const { jsPDF } = window.jspdf;
    const originalContent = document.querySelector(`#${elementId} .model-content`);

    // ★★★ ここから追加 ★★★
    // H1タグからタイトルを取得、なければデフォルト名
    const titleElement = originalContent.querySelector('h1');
    let pdfTitle = "gemini-export";
    if (titleElement) {
        // ファイル名として使えない文字を削除・置換
        pdfTitle = titleElement.textContent.trim().replace(/[\\/:*?"<>|]/g, '_');
    }
    // ★★★ ここまで追加 ★★★

    const printableArea = document.createElement('div');
    printableArea.style.cssText = 'position:absolute; left:-9999px; width:1024px; padding:50px; background:#fff;';
    printableArea.className = 'prose max-w-none';
    const headerHtml = `<div style="margin-bottom: 40px; border-bottom: 1px solid #ddd; padding-bottom: 20px;"><h1 style="font-size: 24px; margin: 0;">生成された解説記事</h1><p style="text-align: right; margin: 0; color: #555;">${new Date().toLocaleString('ja-JP')}</p></div>`;
    const contentClone = originalContent.cloneNode(true);
    printableArea.innerHTML = headerHtml;
    printableArea.appendChild(contentClone);
    document.body.appendChild(printableArea);
    const canvas = await html2canvas(printableArea, { scale: 2 });
    document.body.removeChild(printableArea);

    const imgData = canvas.toDataURL('image/png');
    const pdf = new jsPDF({
        orientation: 'portrait',
        unit: 'px',
        format: [canvas.width, canvas.height]
    });
    pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);

    // ★★★ ファイル名を動的に変更 ★★★
    pdf.save(`${pdfTitle}.pdf`);
}
    function showError(message) {
        errorMessage.textContent = message;
        errorBox.classList.remove('hidden');
    }
    // --- 7. 設定モーダルのロジック (セクションを新設) ---
// 設定ボタンを押したらモーダル表示
settingsBtn.addEventListener('click', () => {
    // 現在保存されているキーを読み込んで入力欄に表示
    apiKeyInput.value = localStorage.getItem('user_gemini_api_key') || '';
    settingsModal.classList.remove('hidden');
});

// キャンセルボタンでモーダルを閉じる
closeModalBtn.addEventListener('click', () => {
    settingsModal.classList.add('hidden');
});

// 保存ボタンの処理
saveApiKeyBtn.addEventListener('click', () => {
    const userApiKey = apiKeyInput.value.trim();
    if (userApiKey) {
        localStorage.setItem('user_gemini_api_key', userApiKey);
        alert('APIキーを保存しました。');
    } else {
        // 入力が空ならキーを削除
        localStorage.removeItem('user_gemini_api_key');
        alert('APIキーを削除しました。');
    }
    settingsModal.classList.add('hidden');
});

// 削除ボタンの処理
clearApiKeyBtn.addEventListener('click', () => {
    localStorage.removeItem('user_gemini_api_key');
    apiKeyInput.value = '';
    alert('APIキーを削除しました。');
});
</script>
</body>
</html>
































