<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>図付きAIジェネレーター</title>
    <link rel="icon" href="assets/icon.png" type="image/png">
    <script src="https://cdn.auth0.com/js/auth0-spa-js/2.1/auth0-spa-js.production.js"></script>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" integrity="sha384-n8MVd4RsNIU0tAv4ct0nTaAbDJwPJzDEaqSD1odI+WdtXRGWt2kTvGFasHpSy3SV" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" integrity="sha384-XjKyOOlGwcjNTAIQHIpgOno0Hl1YQqzUOEleOLALmuqehneUG+vnGctmUb0ZY0l8" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', 'Noto Sans JP', sans-serif; }
        .loader { border: 4px solid #f3f3f3; border-top: 4px solid #3498db; border-radius: 50%; width: 24px; height: 24px; animation: spin 1s linear infinite; }
        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
        .prose h1 { font-size: 1.875rem; } .prose h2 { font-size: 1.5rem; border-bottom: 1px solid #e5e7eb; padding-bottom: 0.5rem; margin-top: 1.5rem;}
        .prose h3 { font-size: 1.25rem; } .prose p, .prose ul, .prose ol { line-height: 1.75; }
        .prose pre { background-color: #f3f4f6; padding: 1rem; border-radius: 0.5rem; }
        #chat-history { scroll-behavior: smooth; }
    </style>
</head>
<body class="bg-gray-100 h-screen flex flex-col">

    <header class="bg-white shadow-sm w-full">
        <div class="container mx-auto p-4 max-w-5xl flex justify-between items-center">
            <div class="text-left">
                <h1 class="text-2xl md:text-3xl font-bold text-gray-900">図付きAIジェネレーター</h1>
                <p class="text-gray-500 text-sm mt-1">AIとの対話で、Markdown・図・数式を含む解説記事を生成</p>
            </div>
            <div id="auth-area" class="flex items-center space-x-4">
                <button id="btn-logout" class="hidden bg-gray-500 text-white font-bold py-2 px-4 rounded">ログアウト</button>
            </div>
        </div>
    </header>

    <main class="flex-1 container mx-auto p-4 max-w-5xl flex flex-col overflow-hidden">
        <div id="mode-selection-area" class="p-4 bg-white rounded-lg shadow-md mb-4">
            <h3 class="font-semibold text-lg text-center mb-4">ご利用方法を選択してください</h3>
            <div class="flex justify-center space-x-8">
                <div><input type="radio" id="mode-login" name="usage-mode" value="login" class="mr-2"><label for="mode-login">ログインして利用 (5回/日)</label></div>
                <div><input type="radio" id="mode-byok" name="usage-mode" value="byok" class="mr-2"><label for="mode-byok">APIキーを入力して利用 (無制限)</label></div>
            </div>
            <div id="login-action-area" class="hidden text-center mt-4">
                <button id="btn-login" class="bg-blue-600 text-white font-bold py-2 px-4 rounded hover:bg-blue-700">Googleアカウントでログイン</button>
            </div>
            <div id="byok-action-area" class="hidden mt-4 p-4 border-t">
                <div>
                    <label for="api-key-input" class="block text-sm font-medium text-gray-700">ご自身のGemini APIキーを入力してください。</label>
                    <div class="flex items-center gap-2">
                        <input type="password" id="api-key-input" class="w-full px-3 py-2 text-gray-700 border rounded-lg focus:outline-none" placeholder="g.co/ai/idx... から取得したキー">
                        <button id="save-api-key-btn" class="px-4 py-2 bg-blue-600 text-white font-medium rounded-md hover:bg-blue-700">保存</button>
                    </div>
                    <p class="mt-2 text-xs text-red-500">注意：APIキーはブラウザ内に保存されます。公共のPCなどでは設定しないでください。</p>
                </div>
                <div>
                    <label for="model-select" class="block text-sm font-medium text-gray-700">使用するモデル:</label>
                    <select id="model-select" class="mt-1 block w-full pl-3 pr-10 py-2 text-base border-gray-300 focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 sm:text-sm rounded-md">
                        <option value="gemini-2.5-pro">2.5 Pro
                        <option value="gemini-2.5-flash">2.5 flash</option>
                        <option value="gemini-2.0-pro">2.0 pro</option>
                    </select>
                </div>
            </div>
        </div>

        <div id="chat-container" class="hidden flex-1 flex flex-col overflow-hidden">
            <div id="chat-history" class="flex-1 space-y-4 overflow-y-auto p-4 bg-white rounded-t-lg shadow-inner">
                <div class="p-4 bg-blue-50 rounded-lg text-gray-700">
                    <p class="font-semibold">アシスタント</p><p>こんにちは！どのような解説記事を作成しますか？</p>
                </div>
            </div>
            <div id="chat-input-area" class="p-4 bg-white border-t border-gray-200 rounded-b-lg">
                <div id="error-box" class="mb-4 bg-red-100 border border-red-400 text-red-700 px-4 py-3 rounded-lg relative hidden" role="alert">
                    <strong class="font-bold">エラー:</strong><span class="block sm:inline" id="error-message"></span>
                </div>
                <div class="flex items-center space-x-3">
                    <textarea id="prompt" rows="1" class="w-full p-3 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-blue-500 transition resize-none" placeholder="メッセージを入力..."></textarea>
                    <button id="generate-btn" class="bg-blue-600 text-white font-bold py-3 px-5 rounded-lg hover:bg-blue-700 flex items-center justify-center disabled:bg-gray-400">
                        <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 10l7-7m0 0l7 7m-7-7v18" /></svg>
                    </button>
                </div>
            </div>
        </div>
    </main>

    <script>
        // --- 1. 要素の取得 ---
        const loginBtn = document.getElementById('btn-login');
        const logoutBtn = document.getElementById('btn-logout');
        const generateBtn = document.getElementById('generate-btn');
        const promptTextarea = document.getElementById('prompt');
        const chatHistoryDiv = document.getElementById('chat-history');
        const errorBox = document.getElementById('error-box');
        const errorMessage = document.getElementById('error-message');
        const modeSelectionArea = document.getElementById('mode-selection-area');
        const chatContainer = document.getElementById('chat-container');
        const radioLogin = document.getElementById('mode-login');
        const radioByok = document.getElementById('mode-byok');
        const loginActionArea = document.getElementById('login-action-area');
        const byokActionArea = document.getElementById('byok-action-area');
        const apiKeyInput = document.getElementById('api-key-input');
        const saveApiKeyBtn = document.getElementById('save-api-key-btn');
    
        // --- 2. 変数の初期化 ---
        let auth0Client = null;
        let chatHistory = [{ role: "model", parts: [{ text: "こんにちは！どのような解説記事を作成しますか？" }] }];

        // --- 3. Auth0 クライアントの設定と初期化 ---
        const auth0Config = {
            domain: "dev-x55cpyrdwlq2c0p2.us.auth0.com",
            clientId: "gNGTdI71kRMz2xAzG0gGgTzbGZJKzqD8",
            authorizationParams: {
                redirect_uri: window.location.origin,
                audience: "https://gemini-enhancer.vercel.app/api"
            }
        };

        window.addEventListener('load', async () => {
            try {
                auth0Client = await auth0.createAuth0Client(auth0Config);
                const query = window.location.search;
                if (query.includes("code=") && query.includes("state=")) {
                    await auth0Client.handleRedirectCallback();
                    window.history.replaceState({}, document.title, "/");
                }
            } catch(e) {
                console.error("Auth0の初期化に失敗:", e);
                showError("認証サービスの初期化に失敗。");
            } finally {
                updateUI();
            }
        });

    // --- 4. UI更新とイベント処理 ---
    const updateUI = async () => {
        if (!auth0Client) return;
        const isAuthenticated = await auth0Client.isAuthenticated();
        const userApiKey = localStorage.getItem('user_gemini_api_key');
        const isLoggedInOrHasKey = isAuthenticated || userApiKey;

        modeSelectionArea.classList.toggle('hidden', isLoggedInOrHasKey);
        chatContainer.classList.toggle('hidden', !isLoggedInOrHasKey);
        logoutBtn.classList.toggle('hidden', !isAuthenticated && !userApiKey);
        
        const isReady = isLoggedInOrHasKey;
        promptTextarea.disabled = !isReady;
        generateBtn.disabled = !isReady;
        if(!isReady) {
          promptTextarea.placeholder = "利用するには、上記の方法を選択してください";
        } else {
          promptTextarea.placeholder = "メッセージを入力...";
        }
    };

    loginBtn.addEventListener('click', () => auth0Client.loginWithRedirect());
    logoutBtn.addEventListener('click', () => {
        localStorage.removeItem('user_gemini_api_key');
        auth0Client.logout({ logoutParams: { returnTo: window.location.origin } });
    });
    
    radioLogin.addEventListener('change', () => {
        loginActionArea.classList.remove('hidden');
        byokActionArea.classList.add('hidden');
    });
    radioByok.addEventListener('change', () => {
        loginActionArea.classList.add('hidden');
        byokActionArea.classList.remove('hidden');
    });
    
    saveApiKeyBtn.addEventListener('click', () => {
        const userApiKey = apiKeyInput.value.trim();
        if (userApiKey) {
            localStorage.setItem('user_gemini_api_key', userApiKey);
            alert('APIキーを保存しました。');
            updateUI();
        } else {
            alert('APIキーが入力されていません。');
        }
    });
    
    // --- 5. チャット機能のコアロジック ---
    mermaid.initialize({ startOnLoad: false, theme: 'default' });
    promptTextarea.addEventListener('keydown', (e) => {
        if (e.key === 'Enter' && !e.shiftKey) { e.preventDefault(); generateContent(); }
    });
    generateBtn.addEventListener('click', generateContent);

    async function generateContent() {
    const userPrompt = promptTextarea.value;
    if (!userPrompt.trim()) return;
    
    addMessageToHistory('user', userPrompt);
    promptTextarea.value = '';
    promptTextarea.style.height = 'auto'; // テキストエリアの高さをリセット

    generateBtn.disabled = true;
    addTypingIndicator();
    
    try {
        const markdownText = await generateTextFromApi();
        removeTypingIndicator();
        addMessageToHistory('model', markdownText);
    } catch (error) {
        console.error('Error:', error);
        showError(error.message || '不明なエラーが発生しました。');
        removeTypingIndicator();
    } finally {
        // ★★★ 修正箇所 ★★★
        // 常にUIの状態を正しくチェックしてボタンの有効/無効を決定する
        updateUI(); 
    }
}
    
    async function generateTextFromApi() {
        const userApiKey = localStorage.getItem('user_gemini_api_key');

        if (!userApiKey) {
            // --- 無料ユーザー（サーバー経由）の処理 ---
            console.log("サーバー経由で実行します（回数制限・認証あり）");
            if (!auth0Client) throw new Error("認証クライアントが初期化されていません。");
            const isAuthenticated = await auth0Client.isAuthenticated();
            if (!isAuthenticated) throw new Error("ログインが必要です。");
            
            const accessToken = await auth0Client.getTokenSilently();

            const response = await fetch('/api/generate', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${accessToken}`
                },
                body: JSON.stringify({ chatHistory: chatHistory }), // systemPromptはサーバー側で定義
            });
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error || `サーバーエラー (${response.status})`);
            }
            const data = await response.json();
            return data.text;

        } else {
            // ★★★ ここからがBYOKユーザー用の修正箇所 ★★★
            console.log("ユーザー提供のAPIキーを使用して2エージェント構成で実行します。");

            const selectedModel = document.getElementById('model-select').value;
            // gemini-2.5-proはツールをサポートしていないため、1.5-proに強制する
            const researcherModelName = selectedModel;
            const writerModelName = selectedModel;
            
            const apiUrl = (modelName) => `https://generativelanguage.googleapis.com/v1beta/models/${modelName}:generateContent?key=${userApiKey}`;

            try {
                // --- 1. エージェント1 (調査担当) の実行 ---
                console.log("エージェント1 (調査担当) を実行中...");
                const researcherSystemPrompt = `## あなたの役割
                あなたは「リサーチャー」です。ユーザーからの要求に基づき、Google検索ツールを徹底的に活用して、正確で包括的な情報を収集・整理することが唯一の任務です。
            
                
                ## 行動原則
                - ユーザーの要求に関連する情報を、信頼できる情報源から複数収集します。情報が足りない場合でも、その要求を満たす最も包括的な回答を生成し、必ず一つの出力で完結するようにしてください。
                - 収集した情報を、次の担当者が記事を執筆しやすいように、構造化された箇条書き形式で客観的に要約してください。
                - あなた自身が記事の本文を執筆したり、解説を加えたりする必要はありません。事実のリストアップに徹してください。
                - 最後に参考文献を追記してください。閲覧年月日（${new Date().toISOString().slice(0, 10)}）、タイトル、著者（サイト管理者、著者、出版社等）、URL（ウェブサイトの場合のみ）
                - 図や表の作成は行いません。

                ### 参考文献について
                google searchを用いて参照したウェブサイトないし書籍のみを出力してください。google searchを使用しなかった場合は『なし』と表記してください
                
                ## 出力形式
                必ず以下のMarkdown形式で出力してください。
                \`\`\`markdown
                ## 調査結果サマリ
                ### トピック1
                - 重要な事実A
                - 重要な事実B
                ### トピック2
                - 重要な事実C
                - 関連データD
                \`\`\``;
                
                const researcherPayload = {
                    contents: chatHistory,
                    systemInstruction: { parts: [{ text: researcherSystemPrompt }] },
                    tools: [{ "googleSearch": {} }]
                };

                const researcherResponse = await fetch(apiUrl(researcherModelName), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(researcherPayload),
                });

                if (!researcherResponse.ok) {
                    const errorData = await researcherResponse.json();
                    throw new Error(`[調査担当] Google API エラー (${researcherResponse.status}): ${errorData.error?.message || '不明なエラー'}`);
                }
                const researcherResult = await researcherResponse.json();
                const researchSummary = researcherResult.candidates?.[0]?.content?.parts?.[0]?.text;
                if (!researchSummary) {
                    throw new Error("[調査担当] APIからの応答が予期した形式ではありません。");
                }
                console.log("エージェント1 完了。調査結果:\n", researchSummary);
                
                // --- 2. エージェント2 (記事化担当) の実行 ---
                console.log("エージェント2 (記事化担当) を実行中...");
                const originalUserPrompt = chatHistory[chatHistory.length - 1].parts[0].text;
                const writerSystemPrompt = `## あなたの役割
あなたは「テクニカルライター兼イラストレーター」です。リサーチャーから提供された「調査結果サマリ」を読者にとって最も理解しやすい解説記事にすることが唯一の任務です。与えられた文字列の整理が目的であり、自身の思考や解釈を加えないでください。

## 行動原則
- **与えられた「調査結果サマリ」の情報のみを信頼できる情報源とし、それ以外の知識やGoogle検索は後述する唯一の目的を除き絶対に使用しないでください。**
- 文章による説明だけでは不十分だと判断した箇所では、**Mermaidを用いてフローチャートなどの図を積極的に使って視覚的に表現してください。ただし、図がかえって理解を妨げると予想される、または明らかに無意味な場合は使用しないようにしてください。**
- 数式や科学的表記が必要な場合は、**LaTeXを必ず使用してください。**
- 最終的な出力は、一つの完成された記事として構成してください。

## 利用可能なツール
Mermaid: \`\`\`mermaid コードブロックで図を作成します。フローチャート、シーケンス図などが利用可能です。
- エラーが出ないか確認を行ってください。その際にgoogle検索の利用を許可します。
- ノードのテキストに特殊文字 \`()\` \`:\` などを含む場合は、必ずテキスト全体を \`""\` で囲んでください。例: \`A["天然ガス (CH4)"] --> B["N2: 精製"]\`
- 複数のグループ（集合）とその間の関係性を表現する場合は、以下の【完璧な構造の例】に厳密に従ってください。
【完璧な構造の例】
\`\`\`mermaid
graph LR
    %% 正しいサブグラフ構文: subgraph ID ["表示タイトル"]
    subgraph domain ["始域"]
        x1
        x2
        x3
    end
    subgraph codomain ["終域"]
        y1
        y2
        y3
        y4
    end

    %% グループ定義後に接続を記述
    x1 --> y1
    x2 --> y2
    x3 --> y3
\`\`\`
Markdown: 構造化された文章を作成します。
Latex: 数式を表現します。

参考文献と資料:
実際に参照したWebページや書籍のみを、解説の最後に「## 参考文献」セクションを設け、以下の記法に従ってリストアップしてください。リストアップする際、その資料ごとに改行してください。本文中の関連箇所には [1], [2] のように引用番号を付与してください。
ウェブサイト: 著者名（任意）「記事タイトル」サイト名. <URL>. (閲覧日: ${new Date().toISOString().slice(0, 10)})
書籍: 著者名『書籍名』出版社, 出版年.
与えられた参考文献が存在しない場合、参考文献セクションには「なし」とだけ記載してください。
複数の参考文献が存在する場合はそれらごとに[1][2]のように分け、それぞれ改行して見やすいように表記してください。
読者のさらなる学習のために推奨できる資料がある場合は、「## 参考資料」というセクションを参考文献の後に設け、リスト形式で提示してください。`;

                const writerPrompt = `以下の【元の依頼】と【調査結果サマリ】に基づいて、指示通りに図表を多用した完成された解説記事を作成してください。\n\n【元の依頼】\n${originalUserPrompt}\n\n【調査結果サマリ】\n${researchSummary}`;

                const writerPayload = {
                    contents: [{ role: "user", parts: [{ text: writerPrompt }] }],
                    systemInstruction: { parts: [{ text: writerSystemPrompt }] },
                    // 記事化担当はツールを使用しない
                };

                const writerResponse = await fetch(apiUrl(writerModelName), {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(writerPayload),
                });

                if (!writerResponse.ok) {
                    const errorData = await writerResponse.json();
                    throw new Error(`[記事化担当] Google API エラー (${writerResponse.status}): ${errorData.error?.message || '不明なエラー'}`);
                }

                const writerResult = await writerResponse.json();
                const finalArticle = writerResult.candidates?.[0]?.content?.parts?.[0]?.text;

                if (!finalArticle) {
                    throw new Error("[記事化担当] APIからの応答が予期した形式ではありません。");
                }
                return finalArticle;

            } catch (error) {
                console.error("Google API direct call error:", error);
                if (error.message.includes(userApiKey)) {
                    throw new Error("Google APIへの接続中にエラーが発生しました。APIキーが正しいか確認してください。");
                }
                throw error;
            }
        }
    }

    // --- 6. チャットUIのヘルパー関数群 ---
    function addMessageToHistory(role, content) {
        const messageWrapper = document.createElement('div');
        if (role === 'user') {
            messageWrapper.className = "p-4 bg-gray-100 rounded-lg ml-auto max-w-4/5";
            messageWrapper.innerHTML = `<p class="font-semibold text-right">あなた</p><p class="whitespace-pre-wrap">${content.replace(/</g, "&lt;").replace(/>/g, "&gt;")}</p>`;
            chatHistory.push({ role: "user", parts: [{ text: content }] });
        } else {
            const responseId = `model-response-${chatHistory.length}`;
            messageWrapper.id = responseId;
            messageWrapper.className = "p-4 bg-blue-50 rounded-lg text-gray-700";
            const exportButtons = `
                <div class="export-buttons flex items-center gap-2 mt-3 border-t pt-2">
                    <button onclick="copyToClipboard('${responseId}')" class="text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 px-2 py-1 rounded">Markdownコピー</button>
                    <button onclick="exportPdf('${responseId}')" class="text-xs bg-gray-200 hover:bg-gray-300 text-gray-700 px-2 py-1 rounded">PDFエクスポート</button>
                </div>`;
            messageWrapper.innerHTML = `<p class="font-semibold">アシスタント</p><div class="prose max-w-none model-content">${content}</div>${exportButtons}`;
            chatHistory.push({ role: "model", parts: [{ text: content }] });
            renderContent(messageWrapper.querySelector('.model-content'));
        }
        chatHistoryDiv.appendChild(messageWrapper);
        chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
    }

    function addTypingIndicator() {
        const typingIndicator = document.createElement('div');
        typingIndicator.id = "typing-indicator";
        typingIndicator.className = "p-4 bg-blue-50 rounded-lg text-gray-700 flex items-center space-x-2";
        typingIndicator.innerHTML = `<p class="font-semibold">アシスタント</p><div class="loader"></div>`;
        chatHistoryDiv.appendChild(typingIndicator);
        chatHistoryDiv.scrollTop = chatHistoryDiv.scrollHeight;
    }

    function removeTypingIndicator() {
        const indicator = document.getElementById('typing-indicator');
        if (indicator) indicator.remove();
    }

    function replaceCitationsWithLinks(element, refCount) {
        const walker = document.createTreeWalker(element, NodeFilter.SHOW_TEXT);
        let node;
        const nodesToModify = [];
        while (node = walker.nextNode()) {
            if (node.parentElement.closest('pre, code')) continue;
            if (/\[\d+\]/.test(node.nodeValue)) {
                nodesToModify.push(node);
            }
        }
        nodesToModify.forEach(node => {
            const fragment = document.createDocumentFragment();
            const parts = node.nodeValue.split(/(\[\d+\])/g);
            parts.forEach(part => {
                const match = part.match(/^\[(\d+)\]$/);
                if (match) {
                    const num = parseInt(match[1], 10);
                    if (num > 0 && num <= refCount) {
                        const sup = document.createElement('sup');
                        sup.className = "font-bold text-blue-600";
                        const link = document.createElement('a');
                        link.href = `#ref-${num}`;
                        link.textContent = part;
                        sup.appendChild(link);
                        fragment.appendChild(sup);
                    } else {
                        fragment.appendChild(document.createTextNode(part));
                    }
                } else {
                    fragment.appendChild(document.createTextNode(part));
                }
            });
            node.parentNode.replaceChild(fragment, node);
        });
    }

    async function renderContent(targetElement) {
        let markdown = targetElement.innerHTML;
        const mermaidBlocks = [];
        markdown = markdown.replace(/```mermaid\n([\s\S]*?)\n```/g, (match, code) => {
            const placeholderId = `mermaid-placeholder-${mermaidBlocks.length}`;
            mermaidBlocks.push(code);
            return `<div id="${placeholderId}"></div>`;
        });
        targetElement.innerHTML = marked.parse(markdown);
        
        const refHeader = Array.from(targetElement.querySelectorAll('h1, h2')).find(h => h.textContent.trim() === '参考文献');
        let refCount = 0;
        if (refHeader) {
            let refList = refHeader.nextElementSibling;
            while (refList && !['OL', 'UL'].includes(refList.tagName)) {
                refList = refList.nextElementSibling;
            }
            if (refList) {
                const listItems = refList.querySelectorAll('li');
                refCount = listItems.length;
                listItems.forEach((li, index) => {
                    li.id = `ref-${index + 1}`;
                });
            }
        }
        if (refCount > 0) {
            replaceCitationsWithLinks(targetElement, refCount);
        }

        mermaidBlocks.forEach((code, index) => {
            const placeholder = targetElement.querySelector(`#mermaid-placeholder-${index}`);
            if (placeholder) {
                const container = document.createElement('div');
                container.className = 'mermaid';
                const decoder = document.createElement('textarea');
                decoder.innerHTML = code;
                container.textContent = decoder.value;
                placeholder.replaceWith(container);
            }
        });

        if (targetElement.querySelectorAll('.mermaid').length > 0) {
            try {
                await mermaid.run({ nodes: targetElement.querySelectorAll('.mermaid') });
            } catch (e) {
                console.error("Mermaid rendering error:", e);
                targetElement.querySelectorAll('.mermaid').forEach(el => {
                    if (el.innerHTML.trim() === '') {
                         el.innerHTML = `<div class="p-2 border border-red-400 bg-red-100 text-red-700 rounded">Mermaid図の描画に失敗しました。<br><pre>${el.textContent}</pre></div>`;
                    }
                });
            }
        }
        
        if (window.renderMathInElement) {
            renderMathInElement(targetElement, {
                delimiters: [ {left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false} ],
                throwOnError: false
            });
        }
    }
    
    async function copyToClipboard(elementId) {
        const index = parseInt(elementId.replace('model-response-', ''));
        const originalMarkdown = chatHistory[index].parts[0].text;
        try {
            await navigator.clipboard.writeText(originalMarkdown);
            const button = document.querySelector(`#${elementId} button:first-child`);
            const originalText = button.textContent;
            button.textContent = 'コピーしました！';
            setTimeout(() => { button.textContent = originalText; }, 2000);
        } catch (err) {
            console.error('Failed to copy: ', err);
        }
    }

    async function exportPdf(elementId) {
    const { jsPDF } = window.jspdf;
    const originalContent = document.querySelector(`#${elementId} .model-content`);

    const titleElement = originalContent.querySelector('h1, h2');
    let articleTitle = "生成された解説記事";
    let pdfFilename = "gemini-export";

    if (titleElement) {
        articleTitle = titleElement.textContent.trim();
        pdfFilename = articleTitle.replace(/[\\/:*?"<>|]/g, '_');
    }

    const printableArea = document.createElement('div');
    printableArea.style.cssText = 'position:absolute; left:-9999px; width:1024px; padding:50px; background:#fff;';
    printableArea.className = 'prose max-w-none';
    
    const headerHtml = `<div style="margin-bottom: 40px; border-bottom: 1px solid #ddd; padding-bottom: 20px;"><h1 style="font-size: 24px; margin: 0;">${articleTitle}</h1><p style="text-align: right; margin: 0; color: #555;">${new Date().toLocaleString('ja-JP')}</p></div>`;

    const contentClone = originalContent.cloneNode(true);

    // ★★★ 修正点 ★★★
    // コピーしたコンテンツから、重複するタイトル要素(h1 or h2)を探して削除する
    const clonedTitleElement = contentClone.querySelector('h1, h2');
    if (clonedTitleElement) {
        clonedTitleElement.remove();
    }

    printableArea.innerHTML = headerHtml;
    printableArea.appendChild(contentClone); // タイトルが削除された本文のコピーを追加
    
    document.body.appendChild(printableArea);
    const canvas = await html2canvas(printableArea, { scale: 2 });
    document.body.removeChild(printableArea);

    const imgData = canvas.toDataURL('image/png');
    const pdf = new jsPDF({
        orientation: 'portrait',
        unit: 'px',
        format: [canvas.width, canvas.height]
    });
    pdf.addImage(imgData, 'PNG', 0, 0, canvas.width, canvas.height);

    pdf.save(`${pdfFilename}.pdf`);
}
    function showError(message) {
        errorMessage.textContent = message;
        errorBox.classList.remove('hidden');
    }
</script>
</body>
</html>







